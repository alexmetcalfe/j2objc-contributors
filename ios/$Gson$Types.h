//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: jar:file:libs/gson-2.3.1-sources.jar!com/google/gson/internal/$Gson$Types.java
//

#ifndef _ComGoogleGsonInternal$Gson$Types_H_
#define _ComGoogleGsonInternal$Gson$Types_H_

#include "J2ObjC_header.h"

@class IOSClass;
@class IOSObjectArray;
@protocol JavaLangReflectGenericArrayType;
@protocol JavaLangReflectParameterizedType;
@protocol JavaLangReflectType;
@protocol JavaLangReflectTypeVariable;
@protocol JavaLangReflectWildcardType;

/**
 @brief Copyright (C) 2008 Google Inc.
 Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */

/**
 @brief Static methods for working with types.
 @author Bob Lee
 @author Jesse Wilson
 */
@interface ComGoogleGsonInternal$Gson$Types : NSObject

#pragma mark Public

/**
 @brief Returns an array type whose elements are all instances of <code>componentType</code> .
 @return a java.io.Serializable serializable generic array type.
 */
+ (id<JavaLangReflectGenericArrayType>)arrayOfWithJavaLangReflectType:(id<JavaLangReflectType>)componentType;

/**
 @brief Returns a type that is functionally equal but not necessarily equal according to Object#equals(Object) Object.equals() .
 The returned type is java.io.Serializable .
 */
+ (id<JavaLangReflectType>)canonicalizeWithJavaLangReflectType:(id<JavaLangReflectType>)type;

/**
 @brief Returns true if <code>a</code> and <code>b</code> are equal.
 */
+ (jboolean)equalsWithJavaLangReflectType:(id<JavaLangReflectType>)a
                  withJavaLangReflectType:(id<JavaLangReflectType>)b;

/**
 @brief Returns the component type of this array type.
 @throws ClassCastException if this type is not an array.
 */
+ (id<JavaLangReflectType>)getArrayComponentTypeWithJavaLangReflectType:(id<JavaLangReflectType>)array;

/**
 @brief Returns the element type of this collection type.
 @throws IllegalArgumentException if this type is not a collection.
 */
+ (id<JavaLangReflectType>)getCollectionElementTypeWithJavaLangReflectType:(id<JavaLangReflectType>)context
                                                              withIOSClass:(IOSClass *)contextRawType;

/**
 @brief Returns a two element array containing this map's key and value types in positions 0 and 1 respectively.
 */
+ (IOSObjectArray *)getMapKeyAndValueTypesWithJavaLangReflectType:(id<JavaLangReflectType>)context
                                                     withIOSClass:(IOSClass *)contextRawType;

+ (IOSClass *)getRawTypeWithJavaLangReflectType:(id<JavaLangReflectType>)type;

/**
 @brief Returns a new parameterized type, applying <code>typeArguments</code> to <code>rawType</code> and enclosed by <code>ownerType</code> .
 @return a java.io.Serializable serializable parameterized type.
 */
+ (id<JavaLangReflectParameterizedType>)newParameterizedTypeWithOwnerWithJavaLangReflectType:(id<JavaLangReflectType>)ownerType
                                                                     withJavaLangReflectType:(id<JavaLangReflectType>)rawType
                                                                withJavaLangReflectTypeArray:(IOSObjectArray *)typeArguments OBJC_METHOD_FAMILY_NONE;

+ (id<JavaLangReflectType>)resolveWithJavaLangReflectType:(id<JavaLangReflectType>)context
                                             withIOSClass:(IOSClass *)contextRawType
                                  withJavaLangReflectType:(id<JavaLangReflectType>)toResolve;

/**
 @brief Returns a type that represents an unknown type that extends <code>bound</code> .
 For example, if <code>bound</code> is <code>CharSequence.class</code> , this returns <code>? extends CharSequence</code> . If <code>bound</code> is <code>Object.class</code> , this returns <code>?</code> , which is shorthand for <code>? extends Object</code> .
 */
+ (id<JavaLangReflectWildcardType>)subtypeOfWithJavaLangReflectType:(id<JavaLangReflectType>)bound;

/**
 @brief Returns a type that represents an unknown supertype of <code>bound</code> .
 For example, if <code>bound</code> is <code>String.class</code> , this returns <code>? super String</code> .
 */
+ (id<JavaLangReflectWildcardType>)supertypeOfWithJavaLangReflectType:(id<JavaLangReflectType>)bound;

+ (NSString *)typeToStringWithJavaLangReflectType:(id<JavaLangReflectType>)type;

#pragma mark Package-Private

+ (jboolean)equalWithId:(id)a
                 withId:(id)b;

/**
 @brief Returns the generic supertype for <code>supertype</code> .
 For example, given a class <code>IntegerSet</code> , the result for when supertype is <code>Set.class</code> is <code>Set<Integer></code> and the result when the supertype is <code>Collection.class</code> is <code>Collection<Integer></code> .
 */
+ (id<JavaLangReflectType>)getGenericSupertypeWithJavaLangReflectType:(id<JavaLangReflectType>)context
                                                         withIOSClass:(IOSClass *)rawType
                                                         withIOSClass:(IOSClass *)toResolve;

/**
 @brief Returns the generic form of <code>supertype</code> .
 For example, if this is <code>ArrayList<String></code> , this returns <code>Iterable<String></code> given the input <code>Iterable.class</code> .
 @param supertype a superclass of, or interface implemented by, this.
 */
+ (id<JavaLangReflectType>)getSupertypeWithJavaLangReflectType:(id<JavaLangReflectType>)context
                                                  withIOSClass:(IOSClass *)contextRawType
                                                  withIOSClass:(IOSClass *)supertype;

+ (id<JavaLangReflectType>)resolveTypeVariableWithJavaLangReflectType:(id<JavaLangReflectType>)context
                                                         withIOSClass:(IOSClass *)contextRawType
                                      withJavaLangReflectTypeVariable:(id<JavaLangReflectTypeVariable>)unknown;

@end

J2OBJC_STATIC_INIT(ComGoogleGsonInternal$Gson$Types)

FOUNDATION_EXPORT IOSObjectArray *ComGoogleGsonInternal$Gson$Types_EMPTY_TYPE_ARRAY_;
J2OBJC_STATIC_FIELD_GETTER(ComGoogleGsonInternal$Gson$Types, EMPTY_TYPE_ARRAY_, IOSObjectArray *)

FOUNDATION_EXPORT id<JavaLangReflectParameterizedType> ComGoogleGsonInternal$Gson$Types_newParameterizedTypeWithOwnerWithJavaLangReflectType_withJavaLangReflectType_withJavaLangReflectTypeArray_(id<JavaLangReflectType> ownerType, id<JavaLangReflectType> rawType, IOSObjectArray *typeArguments);

FOUNDATION_EXPORT id<JavaLangReflectGenericArrayType> ComGoogleGsonInternal$Gson$Types_arrayOfWithJavaLangReflectType_(id<JavaLangReflectType> componentType);

FOUNDATION_EXPORT id<JavaLangReflectWildcardType> ComGoogleGsonInternal$Gson$Types_subtypeOfWithJavaLangReflectType_(id<JavaLangReflectType> bound);

FOUNDATION_EXPORT id<JavaLangReflectWildcardType> ComGoogleGsonInternal$Gson$Types_supertypeOfWithJavaLangReflectType_(id<JavaLangReflectType> bound);

FOUNDATION_EXPORT id<JavaLangReflectType> ComGoogleGsonInternal$Gson$Types_canonicalizeWithJavaLangReflectType_(id<JavaLangReflectType> type);

FOUNDATION_EXPORT IOSClass *ComGoogleGsonInternal$Gson$Types_getRawTypeWithJavaLangReflectType_(id<JavaLangReflectType> type);

FOUNDATION_EXPORT jboolean ComGoogleGsonInternal$Gson$Types_equalWithId_withId_(id a, id b);

FOUNDATION_EXPORT jboolean ComGoogleGsonInternal$Gson$Types_equalsWithJavaLangReflectType_withJavaLangReflectType_(id<JavaLangReflectType> a, id<JavaLangReflectType> b);

FOUNDATION_EXPORT NSString *ComGoogleGsonInternal$Gson$Types_typeToStringWithJavaLangReflectType_(id<JavaLangReflectType> type);

FOUNDATION_EXPORT id<JavaLangReflectType> ComGoogleGsonInternal$Gson$Types_getGenericSupertypeWithJavaLangReflectType_withIOSClass_withIOSClass_(id<JavaLangReflectType> context, IOSClass *rawType, IOSClass *toResolve);

FOUNDATION_EXPORT id<JavaLangReflectType> ComGoogleGsonInternal$Gson$Types_getSupertypeWithJavaLangReflectType_withIOSClass_withIOSClass_(id<JavaLangReflectType> context, IOSClass *contextRawType, IOSClass *supertype);

FOUNDATION_EXPORT id<JavaLangReflectType> ComGoogleGsonInternal$Gson$Types_getArrayComponentTypeWithJavaLangReflectType_(id<JavaLangReflectType> array);

FOUNDATION_EXPORT id<JavaLangReflectType> ComGoogleGsonInternal$Gson$Types_getCollectionElementTypeWithJavaLangReflectType_withIOSClass_(id<JavaLangReflectType> context, IOSClass *contextRawType);

FOUNDATION_EXPORT IOSObjectArray *ComGoogleGsonInternal$Gson$Types_getMapKeyAndValueTypesWithJavaLangReflectType_withIOSClass_(id<JavaLangReflectType> context, IOSClass *contextRawType);

FOUNDATION_EXPORT id<JavaLangReflectType> ComGoogleGsonInternal$Gson$Types_resolveWithJavaLangReflectType_withIOSClass_withJavaLangReflectType_(id<JavaLangReflectType> context, IOSClass *contextRawType, id<JavaLangReflectType> toResolve);

FOUNDATION_EXPORT id<JavaLangReflectType> ComGoogleGsonInternal$Gson$Types_resolveTypeVariableWithJavaLangReflectType_withIOSClass_withJavaLangReflectTypeVariable_(id<JavaLangReflectType> context, IOSClass *contextRawType, id<JavaLangReflectTypeVariable> unknown);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleGsonInternal$Gson$Types)

#endif // _ComGoogleGsonInternal$Gson$Types_H_
