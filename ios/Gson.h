//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: jar:file:libs/gson-2.3.1-sources.jar!com/google/gson/Gson.java
//

#ifndef _ComGoogleGsonGson_H_
#define _ComGoogleGsonGson_H_

#include "J2ObjC_header.h"
#include "TypeAdapter.h"

@class ComGoogleGsonInternalExcluder;
@class ComGoogleGsonJsonElement;
@class ComGoogleGsonLongSerializationPolicyEnum;
@class ComGoogleGsonReflectTypeToken;
@class ComGoogleGsonStreamJsonReader;
@class ComGoogleGsonStreamJsonWriter;
@class IOSClass;
@class JavaIoReader;
@protocol ComGoogleGsonFieldNamingStrategy;
@protocol ComGoogleGsonJsonDeserializationContext;
@protocol ComGoogleGsonJsonSerializationContext;
@protocol ComGoogleGsonTypeAdapterFactory;
@protocol JavaLangAppendable;
@protocol JavaLangReflectType;
@protocol JavaUtilList;
@protocol JavaUtilMap;

#define ComGoogleGsonGson_DEFAULT_JSON_NON_EXECUTABLE NO

/**
 @brief This is the main class for using Gson.
 Gson is typically used by first constructing a Gson instance and then invoking #toJson(Object) or #fromJson(String,Class) methods on it. <p>You can create a Gson instance by invoking <code>new Gson()</code> if the default configuration is all you need. You can also use GsonBuilder to build a Gson instance with various configuration options such as versioning support, pretty printing, custom JsonSerializer s, JsonDeserializer s, and InstanceCreator s.</p> <p>Here is an example of how Gson is used for a simple Class: <pre> Gson gson = new Gson(); // Or use new GsonBuilder().create(); MyType target = new MyType(); String json = gson.toJson(target); // serializes target to Json MyType target2 = gson.fromJson(json, MyType.class); // deserializes json into target2 </pre></p> <p>If the object that your are serializing/deserializing is a <code>ParameterizedType</code> (i.e. contains at least one type parameter and may be an array) then you must use the #toJson(Object,Type) or #fromJson(String,Type) method.  Here is an example for serializing and deserialing a <code>ParameterizedType</code> : <pre> Type listType = new TypeToken&lt;List&lt;String&gt;&gt;() {}.getType(); List&lt;String&gt; target = new LinkedList&lt;String&gt;(); target.add("blah"); Gson gson = new Gson(); String json = gson.toJson(target, listType); List&lt;String&gt; target2 = gson.fromJson(json, listType); </pre></p> <p>See the <a href="https://sites.google.com/site/gson/gson-user-guide">Gson User Guide</a> for a more complete set of examples.</p>
 @author Inderjeet Singh
 @author Joel Leitch
 @author Jesse Wilson
 */
@interface ComGoogleGsonGson : NSObject {
 @public
  id<ComGoogleGsonJsonDeserializationContext> deserializationContext_;
  id<ComGoogleGsonJsonSerializationContext> serializationContext_;
}

#pragma mark Public

/**
 @brief Constructs a Gson object with default configuration.
 The default configuration has the following settings: <ul> <li>The JSON generated by <code>toJson</code> methods is in compact representation. This means that all the unneeded white-space is removed. You can change this behavior with GsonBuilder#setPrettyPrinting() . </li> <li>The generated JSON omits all the fields that are null. Note that nulls in arrays are kept as is since an array is an ordered list. Moreover, if a field is not null, but its generated JSON is empty, the field is kept. You can configure Gson to serialize null values by setting GsonBuilder#serializeNulls() .</li> <li>Gson provides default serialization and deserialization for Enums, Map , java.net.URL , java.net.URI , java.util.Locale , java.util.Date , java.math.BigDecimal , and java.math.BigInteger classes. If you would prefer to change the default representation, you can do so by registering a type adapter through GsonBuilder#registerTypeAdapter(Type,Object) . </li> <li>The default Date format is same as java.text.DateFormat#DEFAULT . This format ignores the millisecond portion of the date during serialization. You can change this by invoking GsonBuilder#setDateFormat(int) or GsonBuilder#setDateFormat(String) . </li> <li>By default, Gson ignores the com.google.gson.annotations.Expose annotation. You can enable Gson to serialize/deserialize only those fields marked with this annotation through GsonBuilder#excludeFieldsWithoutExposeAnnotation() . </li> <li>By default, Gson ignores the com.google.gson.annotations.Since annotation. You can enable Gson to use this annotation through GsonBuilder#setVersion(double) .</li> <li>The default field naming policy for the output Json is same as in Java. So, a Java class field <code>versionNumber</code> will be output as <code>&quot;versionNumber&quot;</code> in Json. The same rules are applied for mapping incoming Json to the Java classes. You can change this policy through GsonBuilder#setFieldNamingPolicy(FieldNamingPolicy) .</li> <li>By default, Gson excludes <code>transient</code> or <code>static</code> fields from consideration for serialization and deserialization. You can change this behavior through GsonBuilder#excludeFieldsWithModifiers(int...) .</li> </ul>
 */
- (instancetype)init;

/**
 @brief This method deserializes the Json read from the specified parse tree into an object of the specified type.
 It is not suitable to use if the specified class is a generic type since it will not have the generic type information because of the Type Erasure feature of Java. Therefore, this method should not be used if the desired type is a generic type. Note that this method works fine if the any of the fields of the specified object are generics, just the object itself should not be a generic type. For the cases when the object is of generic type, invoke #fromJson(JsonElement,Type) .
 @param < T > the type of the desired object
 @param json the root of the parse tree of JsonElement s from which the object is to be deserialized
 @param classOfT The class of T
 @return an object of type T from the json. Returns <code>null</code> if <code>json</code> is <code>null</code> .
 @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
 @since 1.3
 */
- (id)fromJsonWithComGoogleGsonJsonElement:(ComGoogleGsonJsonElement *)json
                              withIOSClass:(IOSClass *)classOfT;

/**
 @brief This method deserializes the Json read from the specified parse tree into an object of the specified type.
 This method is useful if the specified object is a generic type. For non-generic objects, use #fromJson(JsonElement,Class) instead.
 @param < T > the type of the desired object
 @param json the root of the parse tree of JsonElement s from which the object is to be deserialized
 @param typeOfT The specific genericized type of src. You can obtain this type by using the com.google.gson.reflect.TypeToken class. For example, to get the type for <code>Collection<Foo></code> , you should use: <pre> Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType(); </pre>
 @return an object of type T from the json. Returns <code>null</code> if <code>json</code> is <code>null</code> .
 @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
 @since 1.3
 */
- (id)fromJsonWithComGoogleGsonJsonElement:(ComGoogleGsonJsonElement *)json
                   withJavaLangReflectType:(id<JavaLangReflectType>)typeOfT;

/**
 @brief Reads the next JSON value from <code>reader</code> and convert it to an object of type <code>typeOfT</code> .
 Returns <code>null</code> , if the <code>reader</code> is at EOF. Since Type is not parameterized by T, this method is type unsafe and should be used carefully
 @throws JsonIOException if there was a problem writing to the Reader
 @throws JsonSyntaxException if json is not a valid representation for an object of type
 */
- (id)fromJsonWithComGoogleGsonStreamJsonReader:(ComGoogleGsonStreamJsonReader *)reader
                        withJavaLangReflectType:(id<JavaLangReflectType>)typeOfT;

/**
 @brief This method deserializes the Json read from the specified reader into an object of the specified class.
 It is not suitable to use if the specified class is a generic type since it will not have the generic type information because of the Type Erasure feature of Java. Therefore, this method should not be used if the desired type is a generic type. Note that this method works fine if the any of the fields of the specified object are generics, just the object itself should not be a generic type. For the cases when the object is of generic type, invoke #fromJson(Reader,Type) . If you have the Json in a String form instead of a Reader , use #fromJson(String,Class) instead.
 @param < T > the type of the desired object
 @param json the reader producing the Json from which the object is to be deserialized.
 @param classOfT the class of T
 @return an object of type T from the string. Returns <code>null</code> if <code>json</code> is at EOF.
 @throws JsonIOException if there was a problem reading from the Reader
 @throws JsonSyntaxException if json is not a valid representation for an object of type
 @since 1.2
 */
- (id)fromJsonWithJavaIoReader:(JavaIoReader *)json
                  withIOSClass:(IOSClass *)classOfT;

/**
 @brief This method deserializes the Json read from the specified reader into an object of the specified type.
 This method is useful if the specified object is a generic type. For non-generic objects, use #fromJson(Reader,Class) instead. If you have the Json in a String form instead of a Reader , use #fromJson(String,Type) instead.
 @param < T > the type of the desired object
 @param json the reader producing Json from which the object is to be deserialized
 @param typeOfT The specific genericized type of src. You can obtain this type by using the com.google.gson.reflect.TypeToken class. For example, to get the type for <code>Collection<Foo></code> , you should use: <pre> Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType(); </pre>
 @return an object of type T from the json. Returns <code>null</code> if <code>json</code> is at EOF.
 @throws JsonIOException if there was a problem reading from the Reader
 @throws JsonSyntaxException if json is not a valid representation for an object of type
 @since 1.2
 */
- (id)fromJsonWithJavaIoReader:(JavaIoReader *)json
       withJavaLangReflectType:(id<JavaLangReflectType>)typeOfT;

/**
 @brief This method deserializes the specified Json into an object of the specified class.
 It is not suitable to use if the specified class is a generic type since it will not have the generic type information because of the Type Erasure feature of Java. Therefore, this method should not be used if the desired type is a generic type. Note that this method works fine if the any of the fields of the specified object are generics, just the object itself should not be a generic type. For the cases when the object is of generic type, invoke #fromJson(String,Type) . If you have the Json in a Reader instead of a String, use #fromJson(Reader,Class) instead.
 @param < T > the type of the desired object
 @param json the string from which the object is to be deserialized
 @param classOfT the class of T
 @return an object of type T from the string. Returns <code>null</code> if <code>json</code> is <code>null</code> .
 @throws JsonSyntaxException if json is not a valid representation for an object of type classOfT
 */
- (id)fromJsonWithNSString:(NSString *)json
              withIOSClass:(IOSClass *)classOfT;

/**
 @brief This method deserializes the specified Json into an object of the specified type.
 This method is useful if the specified object is a generic type. For non-generic objects, use #fromJson(String,Class) instead. If you have the Json in a Reader instead of a String, use #fromJson(Reader,Type) instead.
 @param < T > the type of the desired object
 @param json the string from which the object is to be deserialized
 @param typeOfT The specific genericized type of src. You can obtain this type by using the com.google.gson.reflect.TypeToken class. For example, to get the type for <code>Collection<Foo></code> , you should use: <pre> Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType(); </pre>
 @return an object of type T from the string. Returns <code>null</code> if <code>json</code> is <code>null</code> .
 @throws JsonParseException if json is not a valid representation for an object of type typeOfT
 @throws JsonSyntaxException if json is not a valid representation for an object of type
 */
- (id)fromJsonWithNSString:(NSString *)json
   withJavaLangReflectType:(id<JavaLangReflectType>)typeOfT;

/**
 @brief Returns the type adapter for <code></code> type.
 @throws IllegalArgumentException if this GSON cannot serialize and deserialize <code>type</code> .
 */
- (ComGoogleGsonTypeAdapter *)getAdapterWithIOSClass:(IOSClass *)type;

/**
 @brief Returns the type adapter for <code></code> type.
 @throws IllegalArgumentException if this GSON cannot serialize and deserialize <code>type</code> .
 */
- (ComGoogleGsonTypeAdapter *)getAdapterWithComGoogleGsonReflectTypeToken:(ComGoogleGsonReflectTypeToken *)type;

/**
 @brief This method is used to get an alternate type adapter for the specified type.
 This is used to access a type adapter that is overridden by a TypeAdapterFactory that you may have registered. This features is typically used when you want to register a type adapter that does a little bit of work but then delegates further processing to the Gson default type adapter. Here is an example: <p>Let's say we want to write a type adapter that counts the number of objects being read from or written to JSON. We can achieve this by writing a type adapter factory that uses the <code>getDelegateAdapter</code> method: <pre> <code></code> class StatsTypeAdapterFactory implements TypeAdapterFactory public int numReads = 0; public int numWrites = 0; public &lt;T&gt; TypeAdapter&lt;T&gt; create(Gson gson, TypeToken&lt;T&gt; type) { final TypeAdapter&lt;T&gt; delegate = gson.getDelegateAdapter(this, type); return new TypeAdapter&lt;T&gt;() { public void write(JsonWriter out, T value) throws IOException { ++numWrites; delegate.write(out, value); } public T read(JsonReader in) throws IOException { ++numReads; return delegate.read(in); } }; } } } </pre> This factory can now be used like this: <pre> <code>StatsTypeAdapterFactory stats = new StatsTypeAdapterFactory(); Gson gson = new GsonBuilder().registerTypeAdapterFactory(stats).create(); // Call gson.toJson() and fromJson methods on objects System.out.println("Num JSON reads" + stats.numReads); System.out.println("Num JSON writes" + stats.numWrites);</code> </pre> Note that since you can not override type adapter factories for String and Java primitive types, our stats factory will not count the number of String or primitives that will be read or written.
 @param skipPast The type adapter factory that needs to be skipped while searching for a matching type adapter. In most cases, you should just pass <i>this</i> (the type adapter factory from where #getDelegateAdapter method is being invoked).
 @param type Type for which the delegate adapter is being searched for.
 @since 2.2
 */
- (ComGoogleGsonTypeAdapter *)getDelegateAdapterWithComGoogleGsonTypeAdapterFactory:(id<ComGoogleGsonTypeAdapterFactory>)skipPast
                                                  withComGoogleGsonReflectTypeToken:(ComGoogleGsonReflectTypeToken *)type;

/**
 @brief Converts a tree of JsonElement s into its equivalent JSON representation.
 @param jsonElement root of a tree of JsonElement s
 @return JSON String representation of the tree
 @since 1.4
 */
- (NSString *)toJsonWithComGoogleGsonJsonElement:(ComGoogleGsonJsonElement *)jsonElement;

/**
 @brief Writes out the equivalent JSON for a tree of JsonElement s.
 @param jsonElement root of a tree of JsonElement s
 @param writer Writer to which the Json representation needs to be written
 @throws JsonIOException if there was a problem writing to the writer
 @since 1.4
 */
- (void)toJsonWithComGoogleGsonJsonElement:(ComGoogleGsonJsonElement *)jsonElement
                    withJavaLangAppendable:(id<JavaLangAppendable>)writer;

/**
 @brief Writes the JSON for <code>jsonElement</code> to <code>writer</code> .
 @throws JsonIOException if there was a problem writing to the writer
 */
- (void)toJsonWithComGoogleGsonJsonElement:(ComGoogleGsonJsonElement *)jsonElement
         withComGoogleGsonStreamJsonWriter:(ComGoogleGsonStreamJsonWriter *)writer;

/**
 @brief This method serializes the specified object into its equivalent Json representation.
 This method should be used when the specified object is not a generic type. This method uses Class#getClass() to get the type for the specified object, but the <code>getClass()</code> loses the generic type information because of the Type Erasure feature of Java. Note that this method works fine if the any of the object fields are of generic type, just the object itself should not be of a generic type. If the object is of generic type, use #toJson(Object,Type) instead. If you want to write out the object to a Writer , use #toJson(Object,Appendable) instead.
 @param src the object for which Json representation is to be created setting for Gson
 @return Json representation of <code>src</code> .
 */
- (NSString *)toJsonWithId:(id)src;

/**
 @brief This method serializes the specified object into its equivalent Json representation.
 This method should be used when the specified object is not a generic type. This method uses Class#getClass() to get the type for the specified object, but the <code>getClass()</code> loses the generic type information because of the Type Erasure feature of Java. Note that this method works fine if the any of the object fields are of generic type, just the object itself should not be of a generic type. If the object is of generic type, use #toJson(Object,Type,Appendable) instead.
 @param src the object for which Json representation is to be created setting for Gson
 @param writer Writer to which the Json representation needs to be written
 @throws JsonIOException if there was a problem writing to the writer
 @since 1.2
 */
- (void)toJsonWithId:(id)src
withJavaLangAppendable:(id<JavaLangAppendable>)writer;

/**
 @brief This method serializes the specified object, including those of generic types, into its equivalent Json representation.
 This method must be used if the specified object is a generic type. For non-generic objects, use #toJson(Object) instead. If you want to write out the object to a Appendable , use #toJson(Object,Type,Appendable) instead.
 @param src the object for which JSON representation is to be created
 @param typeOfSrc The specific genericized type of src. You can obtain this type by using the com.google.gson.reflect.TypeToken class. For example, to get the type for <code>Collection<Foo></code> , you should use: <pre> Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType(); </pre>
 @return Json representation of <code>src</code>
 */
- (NSString *)toJsonWithId:(id)src
   withJavaLangReflectType:(id<JavaLangReflectType>)typeOfSrc;

/**
 @brief This method serializes the specified object, including those of generic types, into its equivalent Json representation.
 This method must be used if the specified object is a generic type. For non-generic objects, use #toJson(Object,Appendable) instead.
 @param src the object for which JSON representation is to be created
 @param typeOfSrc The specific genericized type of src. You can obtain this type by using the com.google.gson.reflect.TypeToken class. For example, to get the type for <code>Collection<Foo></code> , you should use: <pre> Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType(); </pre>
 @param writer Writer to which the Json representation of src needs to be written.
 @throws JsonIOException if there was a problem writing to the writer
 @since 1.2
 */
- (void)toJsonWithId:(id)src
withJavaLangReflectType:(id<JavaLangReflectType>)typeOfSrc
withJavaLangAppendable:(id<JavaLangAppendable>)writer;

/**
 @brief Writes the JSON representation of <code>src</code> of type <code>typeOfSrc</code> to <code>writer</code> .
 @throws JsonIOException if there was a problem writing to the writer
 */
- (void)toJsonWithId:(id)src
withJavaLangReflectType:(id<JavaLangReflectType>)typeOfSrc
withComGoogleGsonStreamJsonWriter:(ComGoogleGsonStreamJsonWriter *)writer;

/**
 @brief This method serializes the specified object into its equivalent representation as a tree of JsonElement s.
 This method should be used when the specified object is not a generic type. This method uses Class#getClass() to get the type for the specified object, but the <code>getClass()</code> loses the generic type information because of the Type Erasure feature of Java. Note that this method works fine if the any of the object fields are of generic type, just the object itself should not be of a generic type. If the object is of generic type, use #toJsonTree(Object,Type) instead.
 @param src the object for which Json representation is to be created setting for Gson
 @return Json representation of <code>src</code> .
 @since 1.4
 */
- (ComGoogleGsonJsonElement *)toJsonTreeWithId:(id)src;

/**
 @brief This method serializes the specified object, including those of generic types, into its equivalent representation as a tree of JsonElement s.
 This method must be used if the specified object is a generic type. For non-generic objects, use #toJsonTree(Object) instead.
 @param src the object for which JSON representation is to be created
 @param typeOfSrc The specific genericized type of src. You can obtain this type by using the com.google.gson.reflect.TypeToken class. For example, to get the type for <code>Collection<Foo></code> , you should use: <pre> Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType(); </pre>
 @return Json representation of <code>src</code>
 @since 1.4
 */
- (ComGoogleGsonJsonElement *)toJsonTreeWithId:(id)src
                       withJavaLangReflectType:(id<JavaLangReflectType>)typeOfSrc;

- (NSString *)description;

#pragma mark Package-Private

- (instancetype)initWithComGoogleGsonInternalExcluder:(ComGoogleGsonInternalExcluder *)excluder
                 withComGoogleGsonFieldNamingStrategy:(id<ComGoogleGsonFieldNamingStrategy>)fieldNamingPolicy
                                      withJavaUtilMap:(id<JavaUtilMap>)instanceCreators
                                          withBoolean:(jboolean)serializeNulls
                                          withBoolean:(jboolean)complexMapKeySerialization
                                          withBoolean:(jboolean)generateNonExecutableGson
                                          withBoolean:(jboolean)htmlSafe
                                          withBoolean:(jboolean)prettyPrinting
                                          withBoolean:(jboolean)serializeSpecialFloatingPointValues
         withComGoogleGsonLongSerializationPolicyEnum:(ComGoogleGsonLongSerializationPolicyEnum *)longSerializationPolicy
                                     withJavaUtilList:(id<JavaUtilList>)typeAdapterFactories;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleGsonGson)

J2OBJC_FIELD_SETTER(ComGoogleGsonGson, deserializationContext_, id<ComGoogleGsonJsonDeserializationContext>)
J2OBJC_FIELD_SETTER(ComGoogleGsonGson, serializationContext_, id<ComGoogleGsonJsonSerializationContext>)

J2OBJC_STATIC_FIELD_GETTER(ComGoogleGsonGson, DEFAULT_JSON_NON_EXECUTABLE, jboolean)

FOUNDATION_EXPORT void ComGoogleGsonGson_init(ComGoogleGsonGson *self);

FOUNDATION_EXPORT ComGoogleGsonGson *new_ComGoogleGsonGson_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void ComGoogleGsonGson_initWithComGoogleGsonInternalExcluder_withComGoogleGsonFieldNamingStrategy_withJavaUtilMap_withBoolean_withBoolean_withBoolean_withBoolean_withBoolean_withBoolean_withComGoogleGsonLongSerializationPolicyEnum_withJavaUtilList_(ComGoogleGsonGson *self, ComGoogleGsonInternalExcluder *excluder, id<ComGoogleGsonFieldNamingStrategy> fieldNamingPolicy, id<JavaUtilMap> instanceCreators, jboolean serializeNulls, jboolean complexMapKeySerialization, jboolean generateNonExecutableGson, jboolean htmlSafe, jboolean prettyPrinting, jboolean serializeSpecialFloatingPointValues, ComGoogleGsonLongSerializationPolicyEnum *longSerializationPolicy, id<JavaUtilList> typeAdapterFactories);

FOUNDATION_EXPORT ComGoogleGsonGson *new_ComGoogleGsonGson_initWithComGoogleGsonInternalExcluder_withComGoogleGsonFieldNamingStrategy_withJavaUtilMap_withBoolean_withBoolean_withBoolean_withBoolean_withBoolean_withBoolean_withComGoogleGsonLongSerializationPolicyEnum_withJavaUtilList_(ComGoogleGsonInternalExcluder *excluder, id<ComGoogleGsonFieldNamingStrategy> fieldNamingPolicy, id<JavaUtilMap> instanceCreators, jboolean serializeNulls, jboolean complexMapKeySerialization, jboolean generateNonExecutableGson, jboolean htmlSafe, jboolean prettyPrinting, jboolean serializeSpecialFloatingPointValues, ComGoogleGsonLongSerializationPolicyEnum *longSerializationPolicy, id<JavaUtilList> typeAdapterFactories) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleGsonGson)

@interface ComGoogleGsonGson_FutureTypeAdapter : ComGoogleGsonTypeAdapter

#pragma mark Public

- (id)readWithComGoogleGsonStreamJsonReader:(ComGoogleGsonStreamJsonReader *)inArg;

- (void)setDelegateWithComGoogleGsonTypeAdapter:(ComGoogleGsonTypeAdapter *)typeAdapter;

- (void)writeWithComGoogleGsonStreamJsonWriter:(ComGoogleGsonStreamJsonWriter *)outArg
                                        withId:(id)value;

#pragma mark Package-Private

- (instancetype)init;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleGsonGson_FutureTypeAdapter)

FOUNDATION_EXPORT void ComGoogleGsonGson_FutureTypeAdapter_init(ComGoogleGsonGson_FutureTypeAdapter *self);

FOUNDATION_EXPORT ComGoogleGsonGson_FutureTypeAdapter *new_ComGoogleGsonGson_FutureTypeAdapter_init() NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleGsonGson_FutureTypeAdapter)

#endif // _ComGoogleGsonGson_H_
