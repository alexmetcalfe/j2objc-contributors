//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: jar:file:libs/gson-2.3.1-sources.jar!com/google/gson/internal/bind/MapTypeAdapterFactory.java
//

#ifndef _ComGoogleGsonInternalBindMapTypeAdapterFactory_H_
#define _ComGoogleGsonInternalBindMapTypeAdapterFactory_H_

#include "J2ObjC_header.h"
#include "TypeAdapterFactory.h"

@class ComGoogleGsonGson;
@class ComGoogleGsonInternalConstructorConstructor;
@class ComGoogleGsonReflectTypeToken;
@class ComGoogleGsonTypeAdapter;

/**
 @brief Adapts maps to either JSON objects or JSON arrays.
 <h3>Maps as JSON objects</h3> For primitive keys or when complex map key serialization is not enabled, this converts Java Map Maps to JSON Objects. This requires that map keys can be serialized as strings; this is insufficient for some key types. For example, consider a map whose keys are points on a grid. The default JSON form encodes reasonably: <pre> <code>Map<Point, String> original = new LinkedHashMap<Point, String>(); original.put(new Point(5, 6), "a"); original.put(new Point(8, 8), "b"); System.out.println(gson.toJson(original, type));</code> </pre> The above code prints this JSON object:<pre> <code></code> { "(5,6)": "a", "(8,8)": "b" } }</pre> But GSON is unable to deserialize this value because the JSON string name is just the Object#toString() toString() of the map key. Attempting to convert the above JSON to an object fails with a parse exception: <pre>com.google.gson.JsonParseException: Expecting object found: "(5,6)" at com.google.gson.JsonObjectDeserializationVisitor.visitFieldUsingCustomHandler at com.google.gson.ObjectNavigator.navigateClassFields ...</pre> <h3>Maps as JSON arrays</h3> An alternative approach taken by this type adapter when it is required and complex map key serialization is enabled is to encode maps as arrays of map entries. Each map entry is a two element array containing a key and a value. This approach is more flexible because any type can be used as the map's key; not just strings. But it's also less portable because the receiver of such JSON must be aware of the map entry convention. <p>Register this adapter when you are creating your GSON instance. <pre> <code>Gson gson = new GsonBuilder() .registerTypeAdapter(Map.class, new MapAsArrayTypeAdapter()) .create();</code> </pre> This will change the structure of the JSON emitted by the code above. Now we get an array. In this case the arrays elements are map entries: <pre> <code>[ [</code> { "x": 5, "y": 6 }, "a", ], [ { "x": 8, "y": 8 }, "b" ] ] }</pre> This format will serialize and deserialize just fine as long as this adapter is registered.
 */
@interface ComGoogleGsonInternalBindMapTypeAdapterFactory : NSObject < ComGoogleGsonTypeAdapterFactory >

#pragma mark Public

- (instancetype)initWithComGoogleGsonInternalConstructorConstructor:(ComGoogleGsonInternalConstructorConstructor *)constructorConstructor
                                                        withBoolean:(jboolean)complexMapKeySerialization;

- (ComGoogleGsonTypeAdapter *)createWithComGoogleGsonGson:(ComGoogleGsonGson *)gson
                        withComGoogleGsonReflectTypeToken:(ComGoogleGsonReflectTypeToken *)typeToken;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleGsonInternalBindMapTypeAdapterFactory)

FOUNDATION_EXPORT void ComGoogleGsonInternalBindMapTypeAdapterFactory_initWithComGoogleGsonInternalConstructorConstructor_withBoolean_(ComGoogleGsonInternalBindMapTypeAdapterFactory *self, ComGoogleGsonInternalConstructorConstructor *constructorConstructor, jboolean complexMapKeySerialization);

FOUNDATION_EXPORT ComGoogleGsonInternalBindMapTypeAdapterFactory *new_ComGoogleGsonInternalBindMapTypeAdapterFactory_initWithComGoogleGsonInternalConstructorConstructor_withBoolean_(ComGoogleGsonInternalConstructorConstructor *constructorConstructor, jboolean complexMapKeySerialization) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleGsonInternalBindMapTypeAdapterFactory)

#endif // _ComGoogleGsonInternalBindMapTypeAdapterFactory_H_
